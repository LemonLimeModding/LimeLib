
plugins {
	id "java-library"
	id "maven-publish"
	id "fabric-loom" version "1.2.7" apply false
}


static def getSubprojectVersion(project) {
	// Get the version from the gradle.properties file
	def version = project.properties["${project.name}_version"]

	if (!version) {
		throw new NullPointerException("Could not find version for " + project.name)
	}

		return version
}


static def getSubprojectArchiveBaseName(project) {
	return "limelib-" + project.name
}


version = project.mod_version
logger.lifecycle("Building LimeLib: " + version)

import groovy.json.JsonSlurper


allprojects {
	group = "tech.lemonlime.lib"



	apply plugin: "maven-publish"

	tasks.withType(GenerateModuleMetadata) {
		enabled = false
	}

	publishing {
		setupRepositories(repositories)
	}

	apply plugin: "java-library"
	apply plugin: "fabric-loom"

	tasks.withType(JavaCompile).configureEach {
		it.options.release = 17
	}

	java {
		// Must be added before the split source sets are setup.
		withSourcesJar()
	}

	loom {
		splitEnvironmentSourceSets()
	}


	allprojects.each { p ->

		loom.mods.register(p.name) {
			sourceSet p.sourceSets.main
			sourceSet p.sourceSets.client
		}
	}


	dependencies {
		minecraft "com.mojang:minecraft:$rootProject.minecraft_version"
		mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
		modApi "net.fabricmc:fabric-loader:${project.loader_version}"


		// Fabric API. This is technically optional, but you probably want it anyway.
		modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

/*


		if (!project.name.contains("baselib")) {
			modImplementation(project(":baselib"))
		}
*/


	}

	tasks.withType(ProcessResources).configureEach {
		inputs.property "version", project.version

		filesMatching("fabric.mod.json") {
			expand "version": project.version
		}
	}

	tasks.withType(AbstractArchiveTask).configureEach {
		preserveFileTimestamps = false
		reproducibleFileOrder = true
	}

	// Run this task after updating minecraft to regenerate any required resources
	tasks.register('generateResources') {
		group = "limelib"
	}



	[jar, sourcesJar].each {
		it.from(rootProject.file("LICENSE")) {
			rename { "${it}-${project.base.archivesName.get()}"}
		}
	}

	if (file("src/client").exists() && !file("src/main").exists()) {
		remapJar {
			additionalClientOnlyEntries.add("LICENSE-${project.base.archivesName.get()}")
		}

		remapSourcesJar {
			additionalClientOnlyEntries.add("LICENSE-${project.base.archivesName.get()}")
		}
	}
}




//javadoc {
//	options {
//		source = "17"
//		encoding = "UTF-8"
//		charSet = "UTF-8"
//		memberLevel = JavadocMemberLevel.PACKAGE
//		links(
//				"https://maven.fabricmc.net/docs/yarn-${rootProject.minecraft_version}${project.yarn_mappings}/"
//		)
//		// Disable the crazy super-strict doclint tool in Java 8
//		addStringOption("Xdoclint:none", "-quiet")
//
//		tags(
//				'apiNote:a:API Note:',
//				'implSpec:a:Implementation Requirements:',
//				'implNote:a:Implementation Note:'
//		)
//	}
//
//	allprojects.each {
//
//		source(it.sourceSets.main.allJava)
//		source(it.sourceSets.client.allJava)
//	}
//
//	classpath = files(sourceSets.main.compileClasspath, sourceSets.client.compileClasspath)
//	include("**/api/**")
//	failOnError true
//}

/*tasks.register('javadocJar', Jar) {
	dependsOn javadoc
	from javadoc.destinationDir
	//Set as `fatjavadoc` to prevent an ide form trying to use this javadoc, over using the modules javadoc
	archiveClassifier = "fatjavadoc"
}*/

//build.dependsOn javadocJar



configurations {
	productionRuntime {
		extendsFrom configurations.minecraftLibraries
		extendsFrom configurations.loaderLibraries
		extendsFrom configurations.minecraftRuntimeLibraries
	}
	productionRuntimeServer
}

dependencies {
	productionRuntime "net.fabricmc:fabric-loader:${project.loader_version}"
	productionRuntime "net.fabricmc:intermediary:${project.minecraft_version}"


}







def addPomMetadataInformation(Project project, MavenPom pom) {
	def modJsonFile = project.file("src/main/resources/fabric.mod.json")

	if (!modJsonFile.exists()) {
		modJsonFile = project.file("src/client/resources/fabric.mod.json")
	}

	def modJson = new JsonSlurper().parse(modJsonFile)
	pom.name = modJson.name
	pom.url = "https://github.com/LemonLimeModding/LimeLib/tree/HEAD/${project.rootDir.relativePath(project.projectDir)}"
	pom.description = modJson.description
	pom.licenses {
		license {
			name = "MIT"
			url = "https://github.com/LemonLimeModding/LimeLib/blob/HEAD/LICENSE"
		}
	}
	pom.developers {
		developer {
			name = "FabricMC"
			url = "https://fabricmc.net/"
		}
	}
	pom.scm {
		connection = "scm:git:https://github.com/LemonLimeModding/LimeLib.git"
		url = "https://github.com/LemonLimeModding/LimeLib"
		developerConnection = "scm:git:git@github.com:LemonLimeModding/LimeLib.git"
	}
	pom.issueManagement {
		system = "GitHub"
		url = "https://github.com/LemonLimeModding/LimeLib/issues"
	}
}


subprojects {



	publishing {
		publications {
			mavenJava(MavenPublication) {
				pom {
					addPomMetadataInformation(project, pom)
				}
				artifact(remapJar) {
					builtBy(remapJar)
				}

				artifact(remapSourcesJar) {
					builtBy remapSourcesJar
				}
			}
		}

		repositories {
			// Add repositories to publish to here.
			// Notice: This block does NOT have the same function as the block in the top level.
			// The repositories here will be used for publishing your artifact, not for
			// retrieving dependencies.
/*			maven {
				name = "LimeLibMaven"
				url = "https://maven.lemonlime.tech/limelib"
				credentials(PasswordCredentials)
				authentication {
					basic(BasicAuthentication)
				}
			}*/
		}
	}

	// We manually handle the pom generation
	loom.disableDeprecatedPomGeneration(publishing.publications.mavenJava)

	javadoc.enabled = false
}

publishing {
	publications {
		mavenJava(MavenPublication) {
			artifact(remapJar) {
				builtBy(remapJar)
			}

			artifact(sourcesJar) {
				builtBy remapSourcesJar
			}

//			artifact javadocJar

			pom {
				addPomMetadataInformation(rootProject, pom)
			}

			pom.withXml {
				def depsNode = asNode().appendNode("dependencies")
				subprojects.each {
					// Dont depend on the deprecated modules in the main artifact.
					if (it.path.startsWith(":deprecated")) {
						return
					}

					def depNode = depsNode.appendNode("dependency")
					depNode.appendNode("groupId", it.group)
					depNode.appendNode("artifactId", it.name)
					depNode.appendNode("version", it.version)
					depNode.appendNode("scope", "compile")
				}
			}
		}
	}

	repositories {
		// Add repositories to publish to here.
		// Notice: This block does NOT have the same function as the block in the top level.
		// The repositories here will be used for publishing your artifact, not for
		// retrieving dependencies.
/*		maven {
			name = "LimeLibMaven"
			url = "https://maven.lemonlime.tech/limelib"
			credentials(PasswordCredentials)
			authentication {
				basic(BasicAuthentication)
			}
		}*/
	}
}

// Required until the deprecation is removed.  main jar that is published to maven does not contain sub modules.
loom.disableDeprecatedPomGeneration(publishing.publications.mavenJava)

void setupRepositories(RepositoryHandler repositories) {
	repositories.mavenLocal() // uncomment for testing
/*	def ENV = System.getenv()
	if (ENV.MAVEN_URL) {
		repositories.maven {
			url ENV.MAVEN_URL
			if (ENV.MAVEN_USERNAME) {
				credentials {
					username ENV.MAVEN_USERNAME
					password ENV.MAVEN_PASSWORD
				}
			}
		}
	}*/

	repositories.maven {
		name "lemonlimeMavenLimelib"
		url "https://maven.lemonlime.tech/limelib"
				credentials(PasswordCredentials)
				authentication {
					basic(BasicAuthentication)
				}
			}


/*	repositories.maven {
		url ENV.MAVEN_URL
		if (ENV.MAVEN_USERNAME) {
			credentials {
				username ENV.MAVEN_USERNAME
				password ENV.MAVEN_PASSWORD
			}
		}
	}*/
}

subprojects.each {


	remapJar.dependsOn("${it.path}:remapJar")
}



dependencies {
	afterEvaluate {
		subprojects.each {

			api project(path: "${it.path}", configuration: "namedElements")
			clientImplementation project("${it.path}:").sourceSets.client.output

		}
	}
}

remapJar {
	afterEvaluate {
		subprojects.each {

			nestedJars.from project("${it.path}").tasks.getByName("remapJar")
		}
	}
}





